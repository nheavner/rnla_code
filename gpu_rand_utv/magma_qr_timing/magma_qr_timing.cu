/*
    -L/usr/local/cuda/lib64 \
	-L/usr/local/magma/lib \
how to compile:
nvcc -c qr_fact_test.cu -I/opt/intel/mkl/include -I/usr/local/magma/include -dc -DADD_ -DMAGMA_WITH_MKL
nvcc -o qr_fact_test.x qr_fact_test.o -L/usr/local/magma/lib -lmagma -lcusolver -lcublas -lgomp
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#include <curand.h>
#include <curand_kernel.h>

#include <cublas_v2.h>
#include <cusolverDn.h>

#include <magma.h>
#include <magma_lapack.h>

#define min( a,b ) ( (a) > (b) ? (b) : (a) )


static timespec start_timer( void ); 

static double stop_timer( timespec t1 );

static void matrix_generate( int m_A, int n_A, double * buff_A, int ldim_A ) {
  int     i, j;

  srand( 10 );
  for ( j = 0; j < n_A; j++ ) {
    for ( i = 0; i < m_A; i++ ) {
      buff_A[ i + j * ldim_A ] = ( double ) rand() / ( double ) RAND_MAX;
    }
  }
}

void print_double_matrix( const char * name, int m_A, int n_A, 
                double * buff_A, int ldim_A ) {
  int  i, j;

  printf( "%s = [\n", name );
  for( i = 0; i < m_A; i++ ) {
    for( j = 0; j < n_A; j++ ) {
      printf( "%le ", buff_A[ i + j * ldim_A ] );
    }
    printf( "\n" );
  }
  printf( "];\n" );
}

//================================================================================================//

int main() {

  // declare, initialize variables
  int n_A_arr[] = {10000};//{2000, 3000,4000,5000,6000,8000,10000,12000,15000,18000};

  int m_A, n_A, ldim_A;
  double * A_pc, * A_pg;
  double * tau_h = NULL; // tau is the scaling factor for each HH vector
						  // such that H = I - tau*q*q', where q is the 
						  // vector stored in the lower portion of A after
						  // factorization
  timespec time1;
  double t_dgeqrf = 0.0;
  int i, j;
  magma_int_t * magInfo = (magma_int_t * ) malloc( sizeof( magma_int_t ) );
  *magInfo = 0;
  double * work_pg;
  magma_int_t lwork;
  int nb;
  double * work_pc, * get_work_pc;
  magma_int_t * jpvt_pc;

  get_work_pc = ( double * ) malloc( sizeof( double ) );

  magma_init();

  for ( i=0; i < sizeof( n_A_arr ) / sizeof( int ) ; i++ ) { 

    printf( "n = %d \n", n_A_arr[ i ] );
  
    m_A = n_A_arr[ i ]; n_A = n_A_arr[ i ]; ldim_A = n_A_arr[ i ];

	t_dgeqrf = 0.0;

	// allocate array on host (cpu)
	magma_dmalloc_pinned( & A_pc, m_A * n_A );

	// allocate array on device (gpu)
	cudaMalloc( & A_pg, m_A * n_A * sizeof( double ) );

	// allocate tau array
	magma_dmalloc_cpu( & tau_h, n_A );

	// allocate pivot tracking array;
	jpvt_pc = ( magma_int_t * ) malloc(n_A * sizeof( magma_int_t ) );
	for ( j=0; j < n_A; j++ ) {
	  jpvt_pc[ j ] = 0;
	}

	// fill cpu array with random standard normal numbers
	matrix_generate( m_A, n_A, A_pc, ldim_A );
	
    // copy matrix from cpu to gpu
	cudaMemcpy( A_pg, A_pc, m_A * n_A * sizeof( double ), cudaMemcpyHostToDevice );

    // allocate work array
	nb = magma_get_dgeqp3_nb( m_A, n_A );
	lwork = 2 * n_A + ( n_A+1 ) * nb;
	lwork = max( ( int ) lwork, m_A * n_A + n_A );
	magma_dmalloc_pinned( & work_pc, lwork );
	cudaMalloc( & work_pg, lwork * sizeof( double ) );

	// compute QR factorization
	cudaDeviceSynchronize();
	time1 = start_timer();

    //magma_dgeqrf2_gpu( m_A, n_A, A_pg, ldim_A, tau_h, magInfo );
	//magma_dgeqp3( m_A, n_A, A_pc, ldim_A, jpvt_pc, tau_h, work_pc, lwork, magInfo );
	magma_dgeqp3_gpu( m_A, n_A, A_pg, ldim_A, jpvt_pc, tau_h, work_pg, lwork, magInfo );

	printf("magInfo = %d \n", ( int ) * magInfo);

	cudaDeviceSynchronize();
	t_dgeqrf += stop_timer( time1 );

    printf("%le \n", t_dgeqrf);

	// free memory
	magma_free_pinned( A_pc );
	cudaFree( A_pg );
	cudaFree( work_pg );
	magma_free_pinned( work_pc );
	free( jpvt_pc );
	magma_free_cpu( tau_h );

  }

  printf("\n");

  free( magInfo );
  free( get_work_pc );

  magma_finalize();

  return 0;
}

// ======================================================================== 
static timespec start_timer( void ) { 
  // this function returns a timespec object that contains
  // clock information at the time of this function's execution
  //
  // performs the same function as MATLAB's 'tic'
 
  // declare variables
  timespec t1;

  // get current clock info
  cudaDeviceSynchronize();
  clock_gettime( CLOCK_MONOTONIC, & t1 );

  return t1;

}

// ======================================================================== 
static double stop_timer( timespec t1 ) {
  // this function returns a variable of type double that
  // corresponds to the number of seconds that have elapsed
  // since the time that t1 was generated by start_timer
  // 
  // performs the same function as MATLAB's 'toc'
  //
  // t1: the output of start_timer; holds clock information
  //     from a function call to start_timer
  
  // declare variables 
  timespec  t2;
  uint64_t  t_elapsed_nsec;
  double    t_elapsed_sec;

  // get current clock info
  cudaDeviceSynchronize();
  clock_gettime(CLOCK_MONOTONIC, & t2);

  // calculate elapsed time
  t_elapsed_nsec = (1000000000L) * (t2.tv_sec - t1.tv_sec) + t2.tv_nsec - t1.tv_nsec;
  t_elapsed_sec = (double) t_elapsed_nsec / (1000000000L);

  return t_elapsed_sec;

}
