#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <cublas_v2.h>
#include "dgemm_gpu.h"

// =========================================================================// Declaration of local prototypes

static void print_double_matrix ( const char * name, int m_A, int n_A,
				double * buff_A, int ldim_A );

static timespec start_timer( void ); 

static double stop_timer( timespec t1 );

// =========================================================================
int main() {

  // some initializations
  int i;
  double d_one = 1.0, d_zero = 0.0;
  char n = 'N', t = 'T';

  // Allocate 3 arrays on CPU
  int m_A, n_A, ldim_A, m_B, n_B, ldim_B, m_C, n_C, ldim_C;

  m_A = 10000; n_A = 10000; ldim_A = m_A; 
  m_B = 10000; n_B = 10000; ldim_B = m_B;
  m_C = n_A; n_C = n_B; ldim_C = n_A;
  const char * A_name = "A";
  const char * B_name = "B";
  const char * C_name = "C";

  double t_dgemm = 0.0;
  timespec time1;

  double * buff_A = ( double * ) malloc( m_A * n_A * sizeof( double ) );
  double * buff_B = ( double * ) malloc( m_B * n_B * sizeof( double ) );
  double * buff_C = ( double * ) malloc( m_C * n_C * sizeof( double ) );
  
  // Allocate 3 arrays on GPU
  double * buff_g_A, * buff_g_B, * buff_g_C;
  cudaMalloc( & buff_g_A, m_A * n_A * sizeof( double ) );
  cudaMalloc( & buff_g_B, m_B * n_B * sizeof( double ) );
  cudaMalloc( & buff_g_C, m_C * n_C * sizeof( double ) );

  // Initialize matrices A,B
  for ( i=0; i<m_A*n_A; i++ ) {
    buff_A[ i ] = ( double ) i;
  }

  for ( i=0; i<m_B*n_B; i++ ) {
    buff_B[ i ] = ( double ) i;
  }

  // print matrices A,B
  //print_double_matrix( A_name, m_A, n_A, buff_A, ldim_A );
  //print_double_matrix( B_name, m_B, n_B, buff_B, ldim_B );

  // transfer host arrays to device (gpu)
  cudaMemcpy( buff_g_A, buff_A, m_A * n_A * sizeof( double ), cudaMemcpyHostToDevice );
  cudaMemcpy( buff_g_B, buff_B, m_B * n_B * sizeof( double ), cudaMemcpyHostToDevice );

  // do the multiplication
  time1 = start_timer();

  for (i=0; i < 100; i++) {
  dgemm_gpu( t, n, n_A, n_B, m_B,
				& d_one, buff_g_A, ldim_A,
				buff_g_B, ldim_B,
				& d_zero, buff_g_C, ldim_C );
  }

  t_dgemm += stop_timer( time1 );
  t_dgemm = t_dgemm / 100;

  // copy and print result on host memory
  cudaMemcpy( buff_C, buff_g_C, m_C * n_C * sizeof( double ), cudaMemcpyDeviceToHost );
  //print_double_matrix( C_name, m_C, n_C, buff_C, ldim_C );

  // print time required for dgemm
  printf( "t_dgemm = %.2e \n", t_dgemm );

  // Free GPU memory
  cudaFree( buff_g_A );
  cudaFree( buff_g_B );
  cudaFree( buff_g_C );
  
  // Free CPU memory
  free( buff_A );
  free( buff_B );
  free( buff_C );

  return 0;

}

// =========================================================================
static void print_double_matrix(const char * name, int m_A, int n_A, 
                double * buff_A, int ldim_A ) {
  int  i, j;

  printf( "%s = [\n", name );
  for( i = 0; i < m_A; i++ ) {
    for( j = 0; j < n_A; j++ ) {
      printf( "%le ", buff_A[ i + j * ldim_A ] );
    }
    printf( "\n" );
  }
  printf( "];\n" );
}

// ======================================================================== 
static timespec start_timer( void ) { 
  // this function returns a timespec object that contains
  // clock information at the time of this function's execution
  //
  // performs the same function as MATLAB's 'tic'
 
  // declare variables
  timespec t1;

  // get current clock info
  cudaDeviceSynchronize();
  clock_gettime( CLOCK_MONOTONIC, & t1 );

  return t1;

}

// ======================================================================== 
static double stop_timer( timespec t1 ) {
  // this function returns a variable of type double that
  // corresponds to the number of seconds that have elapsed
  // since the time that t1 was generated by start_timer
  // 
  // performs the same function as MATLAB's 'toc'
  //
  // t1: the output of start_timer; holds clock information
  //     from a function call to start_timer
  
  // declare variables 
  timespec  t2;
  uint64_t  t_elapsed_nsec;
  double    t_elapsed_sec;

  // get current clock info
  cudaDeviceSynchronize();
  clock_gettime(CLOCK_MONOTONIC, & t2);

  // calculate elapsed time
  t_elapsed_nsec = (1000000000L) * (t2.tv_sec - t1.tv_sec) + t2.tv_nsec - t1.tv_nsec;
  t_elapsed_sec = (double) t_elapsed_nsec / (1000000000L);

  return t_elapsed_sec;

}
